# 设计模式概述

- 软件开发：招式+内功

  - 招式：开发语言+框架
  - 内功：数据结构、算法、设计模式、重构、软件工程

- 定义：在某个上下文中针对某个问题的解决方案，形成可复用的模板

  - 上下文场景、问题、解决方案，复用模板

# 设计原则

- 抽取变化的部分

- 针对接口编程，而不是针对实现编程

- 优先使用组合而不是继承

- 尽量做到交互的对象之间松耦合设计

- 类应该对扩展开放，但对修改关闭

  - 新需求通过添加新代码(类的继承或添加新方法)，避免修改已经实现和测试好的代码

- 依赖倒置原则：依赖抽象，不依赖具体类

- 最少知识原则：只和你的密友谈话

  - 当在设计系统时，对于任何对象，要注意与它所交互的类的数量，以及它和这些类如何交互
  - 封装对象后，只调用封装对象的方法，而不调用封装对象内封装对象的方法
  - 如果想要调用封装对象内的封装对象的方法，就一个函数获取封装对象的封装对象，再一个函数调用其方法

    ```cpp
    struct A {
        void output();
    };
    struct B {
        A a;
    };
    struct C {
        B b; // 封装对象
        void test() { helper(b.a); } // 调用封装对象内的封装对象
        void helper(A &a) { a.output(); }
    };

    ```

- 好莱坞原则：不要打电话给（调用）我们，我们会打电话给（调用）你

  - 防止“依赖腐烂”，比如高层依赖低层同时底层依赖高层
  - 低层组件把自己通过钩子的方式挂进系统，高层组件决定如何使用它们

- 一个类应该只有一个变化的原因

  - 要让每个类保持单一责任

# 分类

- 创建型：对象实例化

  - 单例模式
  - 抽象工厂模式
  - 工厂方法模式
  - 生成器模式
  - 原型模式

- 行为型：类和对象的交互，以及分配责任

  - 策略模式
  - 命令模式
  - 模板方法模式
  - 状态模式
  - 迭代器模式
  - 观察者模式
  - 责任链模式
  - 解释器模式
  - 中介者模式
  - 备忘录模式
  - 访问者模式

- 结构型：组合类或对象得到更大的结构

  - 装饰器模式
  - 适配器模式
  - 组合模式
  - 外观模式
  - 代理模式
  - 桥接模式
  - 蝇量模式

- 其它

  - 复合型：MVC 模式

# 模式

## 策略模式

- 定义了一个算法族，分别封装起来，使得它们之间可以互相变换。策略让算法的变化独立于使用它的客户。

### 示例 (不同鸭子的不同叫声)

- 主类中定义行为类，该行为类可被继承更改。

- 继承主类时，可以实现继承的行为类

- `strategy_pattern.cpp`

## 观察者模式

- 观察者，定义对象之间的一对多依赖，这样当一个对象改变状态时，它的所有依赖者会被通知并自动更新

### 示例 (一个数据中心，多个显示终端)

- 多个观察者从数据中心中提取数据

- 里面有循环引用，需要使用 weak_ptr

- `observer_pattern.cpp`

## 装饰器模式

- 装饰器，给对象动态附加额外的责任

- 一个抽象类，多个实现类，一个装饰器抽象类(继承抽象类，达到类型匹配)

- 多个装饰器实现类可以扩展实现类，用组合和委托的形式来扩展

- 优点：遵循开放闭合原则，扩展性更好

- 缺点：类的个数会很多

### 示例 (咖啡店对不同咖啡添加不同配料，计算价格)

- 饮料是抽象类，浓缩、家常、烘焙、低咖啡因是实现类

- 配料是装饰器抽象类, 封装实现类

- `decorator_pattern.cpp`

## 工厂方法模式

- 在实践中发现，多对多的情况，组合的形式更具有弹性，两个基类，分别可以有派生类，通过组合可以实现弹性设计

- 简单工厂模式 和 工厂方法模式 有一些不同，简单工厂是生产物品的逻辑都在工厂类中，工厂类与使用类组合在一起;工厂方法模式是将一个方法模拟成工厂，子类在继承后可以有自己的工厂方法，进而由子类个性化创建产品

- “工厂方法模式定义了一个创建对象的接口，但让子类决定要实例化哪个类”

- 书上给的例子是多个披萨店有各自风格的披萨，如果都交给一个工厂，那这一个工厂依赖的具体类太多，进而需要每个披萨店有自己的工厂方法

- `abstract_factory_pattern.cpp`

### 示例（不同披萨店制作自己风格的披萨）

- 披萨店类有一个抽象工厂方法，具体披萨店类继承后实现自己的工厂方法

- 这个示例用来说明 "依赖倒置" 原则 (依赖抽象，不依赖具体类)，工厂方法模式中的披萨是抽象类，工厂模式中依赖大量具体类导致设计弹性差

- 依赖倒置中的 "倒置" 是指依赖具体类时，是由高层依赖低层；依赖抽象时，部分具体实现类转为由低层依赖高层

- `factory_methoc_pattern.cpp`

## 抽象工厂模式

- 形式类似于策略模式，但主要作用是生产产品，所以叫工厂模式

- 不同于工厂方法主要使用类继承实现，抽象工厂主要使用组合实现，抽象产品中拥有抽象工厂

- 定义：抽象工厂模式提供一个接口来创建相关或依赖对象的家族，而不需要指定具体类

- 抽象工厂中的一个方法用于创建一组产品，是工厂方法模式

- 可以理解为抽象工厂由工厂方法组成，用于创建一个产品家族，需要一个大接口，如果有改变需求，可能改动会比较大；而工厂方法模式只有一个接口，创建单个产品，改动较小

- `abstract_factory_pattern.cpp`

## 单件模式

- 确保一个类只有一个实例，并提供全局访问点

- `singleton_pattern.cpp`

## 命令模式

- 客户创建调用者、命令、接收者对象；将接收者，即实际执行者的接口封装在命令的 execute() 接口中

- 调用者与命令组合，调用者调用命令的 execute() 接口；命令与接收者组合，调用 execute() 接口则调用接收者的接口

- 每条命令都有一个 undo() 接口，可以用来实现撤销功能

- 常用在线程池、任务队列、事务性日志场景中

- `command_pattern.cpp`

## 适配器模式

- 实现一个接口，封装多个类，使用封装的类的方法，实现接口中的类方法

- 类似装饰器模式，装饰器实现自身接口，适配器封装一个或多个类来实现一个接口

  - 装饰器用于在之前的类方法上添加一些新的责任
  - 适配器用于转换接口

- 定义：将一个类的接口转换成客户期望的另一个接口，让原本不兼容的类可以合作

- 对象适配器和类适配器

  - 对象适配器使用组合的形式，将目标类和被适配类解耦，保持弹性
  - 类适配器使用多重继承的形式，适配器类继承目标类和被适配类，能够快速覆盖被适配类的方法
  - 各有优势，但对象适配器更符合设计模式的原则，用的比较多

- 添加一个适配器，将火鸡封装成鸭子

  - `adapter_pattern.cpp`

## 外观模式

- 封装多个组件，提供外观接口简化场景，调用接口后执行多个组件的接口

- 外观模式和适配器模式都可以封装一个或多个组件，但它们的目的不同

  - 适配器模式的目的是转换接口
  - 外观模式的目的是提供子系统的一个简化的接口

- 定义：为子系统中的一组接口提供了一个统一的接口，定义一个更高级别的接口，使得子系统更容易使用

- 例：构建一个家庭影院，一键启动和停止

  - `facade_pattern.cpp`

## 模板方法模式

- 基类提供一个模板方法，模板方法中定义一个算法的步骤，其中这些步骤可以由基类实现一部分，也可以由派生类继承后改写

- 定义：在一个方法中定义一个算法的骨架，而把一些步骤延迟到子类

- 抽象方法与钩子

  - 抽象方法是基类中的接口，是子类必须实现的方法
  - 钩子用来控制模板中的流程，基类提供一个默认值，子类可以选择实现

- 此模式常用于创建框架，框架控制该做什么事，让使用框架的人指定框架算法中每个步骤实际发生的细节

- 常见于 C++ 的模板实现中，主模板提供算法流程，可以选择自定义比较函数（类似钩子）

- 模板方式采用继承的方式，策略模式采用组合的方式

- 工厂方法是模板方法的一个特例

- 例：使用相同流程制作咖啡和茶

  - `template_method_pattern.cpp`

## 迭代器模式

- 当多个集合合并后，需要遍历不同类型的集合，使用迭代器进行封装。调用者不需要知道每个集合具体是如何存储的。

- 定义：提供一种方式，可以访问一个聚合对象中的元素而又不暴露其潜在的表示

- 例：两个餐厅菜单合并，一个菜单采用链表，另一个菜单采用数组

  - `iterator_pattern.cpp`

  - 一次菜单遍历创建一个迭代器。采用的是外部迭代器的方式，能够直接调用 next() 控制遍历

## 组合模式

- 定义：允许将对象组合成树形结构来表现部分-整体层次结构。组合让客户可以统一处理个别对象和对象组合。

- 基类是组件，子类是组合或叶子，即一个组件可以是组合或叶子，组合中可以包含更多组件，最终形成树形结构

- 例：实现一个菜单树，节点可以是菜单或菜单项，菜单中包含菜单项

  - `composite_pattern.cpp`

## 状态模式

- 定义：允许对象在内部状态改变时改变其行为，对象看起来好像改变了它的类

- 状态模式类图和策略模式类图相似，但意图不同

  - 策略模式封装了算法，在运行时通常已经有合适的策略对象，且一般不会变动
  - 状态模式也封装了算法，在整个运行过程中，状态会不断进行转换

- 封装基于状态的行为并把行为委托给当前状态

- 和过程状态机不同，状态模式用真正的类代表每个状态

- 例：糖果机，最开始的实现是将所有状态转换逻辑放在糖果机中，但增减状态需要修改糖果机大量代码

  - 将状态封装成对象，糖果机中组合状态对象
  - 客户调用糖果机方法，糖果机调用当前状态对象进行状态转换行为
  - 状态对象拥有糖果机对象，状态发生改变时可以修改糖果机当前的状态，由状态决定下一个状态是什么
  - 这里的糖果机也被可以称作“上下文”

  - `state_pattern.cpp`

## 代理模式

- 定义：为另一个对象提供一个替身或占位符来控制对这个对象的访问

- 使用代理模式创建代表对象。代表对象控制对另一个对象的访问，被代表对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。

- 代理控制访问的几种方式：

  - 远程代理控制对远程对象的访问

    - 通过网络访问远程对象的方法。

    - 网络代理包括两部分。一部分是接收客户请求，将请求序列化。另一部分在服务端，接受客户端的代理发出的序列化请求，处理后发送给实际处理的对象

  - 虚拟代理控制对创建开销大的资源的访问

    - 可以延迟对象的创建，直到真正需要。即代理对象也可以处理部分请求，处理不了再创建实际对象，或者在等待创建实际对象时做其他操作

    - 书上的例子是访问页面时由于网络问题，无法一次性显示，可以由代理对象显示“正在加载中”的提示，避免长时间挂起

  - 保护代理基于权限控制对资源的访问

    - 书上的例子是交友信息的访问代理，自己对自己可以配置个人信息，但是不能修改自己的评分；自己对他人不能配置个人信息，但能修改自己的评分

- 代理模式的类图类似装饰器模式，但代码模式强调间接性，且目的不一样。

  - 装饰者为对象添加行为，代理控制对象的访问

  - 装饰者在创建时需要被装饰者已经存在，而代理模式的间接性可以支持服务端和客户端分离（远程代理）和延迟对象创建（虚拟代理）

- 例：交友信息系统中对个人信息的访问控制

  - 个人信息拥有者可以修改自己的信息，但是不能修改自己的评分

  - 个人信息观察者不可以修改信息，但可以对信息进行评分

  - `proxy_pattern.cpp`

## 复合模式

- 定义：将两个或更多的模式结合成一个解决方案，解决重复发生或一般的问题

- 问题引入：

  - 鸭子类
  - 有一只鹅，实现鸭子叫（适配器模式）
  - 统计叫的次数（装饰器模式）
  - 用抽象工厂统一创建，避免忘记某项操作（抽象工厂模式）
  - 统一跟踪管理，实现树形结构（组合模式）
  - 一个学者观察鸭子叫（观察者模式）

- 重要的一个复合模式：MVC 模式

  - View 视图：用于显示
  - Model 模型：存储数据和处理逻辑
  - Controller 控制器：接收视图上的请求，分析后发送给模型端，模型端如果发生改变，通知视图进行修改

    - 视图要显示的数据直接从模型中获取
    - 控制器的主要功能就是解耦视图和模型，接收用户操作并操纵模型
    - 视图用于显示（数据），控制器用于控制（命令）
    - 控制器操纵模型修改数据后，模型推送给视图

- MVC 模式中使用的模式

  - 视图使用组合模式，视图常用于显示界面，界面由有多个组件组成
  - 模型使用观察者模式，定义模型为一个被观察者
  - 控制器使用策略模式，视图可以调用不同的控制区策略来选择一个控件的行为策略

- 例：实现一个节拍器，界面可以查看和修改节拍频率，底层使用音响播放节拍声音

  - 控制器创建视图，视图依赖控制器和模型

  - 视图中的界面显示由模型进行推送

  - 视图上的按钮或信息输入传递给控制器，控制器操纵模型，模型推送视图

  - `mvc_pattern.cpp`

## 桥接模式

- 定义：将实现和抽象放在两个分离的类层次中，彼此可以独立改变。

- 抽象和实现分离比较难理解，查阅资料后给出两个例子。用拆分两个维度理解拆分抽象和实现的关系。

  - 买咖啡时，咖啡的杯子大小和咖啡是否加糖可以分离为两个维度，大中小杯组合是否加糖。
  - 遥控器和电视，遥控器可以分成多种，电视类型也可以分成多种，分离后可以独立改变。组合后形成不同遥控器控制不同电视的方案。

- 个人理解：像是两种策略模式组合起来

- 例：实现上述的遥控器和电视例子，遥控器可以独立改变，电视可以独立改变，顶层桥接组合

  - `bridge_pattern.cpp`

## 生成器模式

- 也被称为建造者模式

- 模式组成

  - 将复杂产品的构建分多个部分，每个部分提供一个接口

  - 生成器负责直接创建产品

  - 可以由客户端提供建造的类型，也可以引入主管类，主管类中管理要建造的类型

  - 客户端直接调用主管对象，主管控制生成器生成产品的类型，最后获取生成的产品

- 工厂模式适合简单完整的对象创建，生成器模式适合复杂多模块的对象创建

- 例：实现建造房子的生成器

  - `builder_pattern.cpp`

## 责任链模式

- 逻辑结构就是一个链表

- 使用场景：发送者需要向多个对象中的一个提交请求，而不想明确指定接收者时

- 可以创建一个对象链来检查请求，每个对象依次检查请求，处理它或将它传给链中的下一个对象

- 例：实现一个日志系统

  - `chain_of_responsibility_pattern.cpp`

## 蝇量模式

- 也被称为享元模式，蝇量表示细粒度的对象，能够改写为复用的对象，可以使用共享的对象

- 区分元素的内部状态（不可变，可共享），外部状态（可变，不共享）

- 将系统中相似对象进行合并，实现共享，减少创建对象的数量，以减少内存占用并提高性能

- 比如：棋盘上的棋子，对于一个棋子来说只有位置会发生变化；绘画时复用颜色相同的元素，元素的大小和位置可变

- 组成：

  - 享元接口：定义享元接口，包含设置外部状态的方法
  - 具体享元类：实现享元接口，包含内部状态和外部状态。用于创建一种享元对象，比如红色的元素
  - 享元工厂：管理享元对象的创建和复用，用于创建多种享元对象，比如红色、蓝色、黑色的元素

- 例：绘画树木，树木的颜色是有限的，对于一种颜色树木，可以出现在不同的位置；工厂内可以创建多种颜色的树木

  - `flyweight_pattern.cpp`

## 解释器模式

- 用于构建一个能够解释特定语言或特定规则的解释器，使用场景比较有限。

- 组成：

  - 抽象表达式：解释器的抽象接口

  - 终结符表达式：用于表示语言中的终结符

  - 非终结符表达式：用于表示语言中的非终结符

  - 上下文：解释器外的一些全部信息，通常用于存储变量的只，保存解释器的状态等

  - 客户端：创建解释器对象，并将表达式传递给表达式解释

- 过程

  - 定义文法：明确语言的终结符和非终结符

  - 构建语法树：根据句子构建语法树结构

  - 创建环境类，包含过程中所有的全局信息

- 例：实现一个加减乘除文法

  - `interpreter_pattern.cpp`

## 中介者模式

- 如果多个对象之间相互引用，则高度耦合，降低系统灵活性。引入中介者，封装对象间的交互，降低耦合度

- 组成

  - 抽象中介者：定义一个与各同事对象通信的接口

  - 具体中介者：实现中介者接口，维护各对象的引用，协调交互

  - 抽象同事类：定义一个与中介者通信的接口

  - 具体同事类：实现同事接口，将消息发送给中介者，由中介者转发给其他同事对象

- MVC 模式中的控制器作用就是中介者

- 中介者模式中的中介者类似观察者模式实现方法

- 例：实现聊天室

  - `mediator_pattern.cpp`

## 备忘录模式

- 让对象返回之前的某个状态

- 将保存的对象和关键对象分离

- 组成：

  - 备忘录：存储原发器内部状态

  - 原发器：关键对象，可以创建备忘录和从备忘录中恢复状态

  - 备忘录管理者：管理备忘录对象

- 例：实现游戏状态保存和恢复

  - `memento_pattern.cpp`

## 原型模式

- 通过复制现有对象来创建新对象，而不是通过构造函数创建

- 用在构造对象复杂的场景中以提高性能，需要深拷贝

- 在 JAVA 中，浅拷贝通过 cloneable 实现，深拷贝通过 serializable 实现

- 原型模式可以和享元模式一起使用，原型模式提供拷贝功能，享元模式提供缓存功能

- 例：实现一个创建逻辑较为繁琐的对象

  - `prototype_pattern.cpp`

# 重要知识点

- 过度使用设计模式可能导致代码过度工程化。用最简单的解决方案完成工作，在需要的地方再引入模式。

- 设计模式和架构设计的区别

  - 设计模式关注于类和对象的组织和交互，架构设计关注于系统整体结构和组件之间交互
  - 设计模式主要用于具体的编程问题，架构设计用于整体高级抽象
