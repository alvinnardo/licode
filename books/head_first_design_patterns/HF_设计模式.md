# 设计模式概述

- 软件开发：招式+内功
  - 招式：开发语言+框架
  - 内功：数据结构、算法、设计模式、重构、软件工程

### 设计原则

- 抽取变化的部分

- 针对接口编程，而不是针对实现编程

- 优先使用组合而不是继承

- 尽量做到交互的对象之间松耦合设计

- 类应该对扩展开放，但对修改关闭

  - 新需求通过添加新代码(类的继承或添加新方法)，避免修改已经实现和测试好的代码

- 依赖倒置原则：依赖抽象，不依赖具体类

- 最少知识原则：只和你的密友谈话

  - 当在设计系统时，对于任何对象，要注意与它所交互的类的数量，以及它和这些类如何交互
  - 封装对象后，只调用封装对象的方法，而不调用封装对象内封装对象的方法
  - 如果想要调用封装对象内的封装对象的方法，就一个函数获取封装对象的封装对象，再一个函数调用其方法

    ```cpp
    struct A {
        void output();
    };
    struct B {
        A a;
    };
    struct C {
        B b; // 封装对象
        void test() { helper(b.a); } // 调用封装对象内的封装对象
        void helper(A &a) { a.output(); }
    };

    ```

- 好莱坞原则：不要打电话给（调用）我们，我们会打电话给（调用）你

  - 防止“依赖腐烂”，比如高层依赖低层同时底层依赖高层
  - 低层组件把自己通过钩子的方式挂进系统，高层组件决定如何使用它们

- 一个类应该只有一个变化的原因

  - 要让每个类保持单一责任

### 策略模式

- 定义了一个算法族，分别封装起来，使得它们之间可以互相变换。策略让算法的变化独立于使用它的客户。

##### 示例 (不同鸭子的不同叫声)

- 主类中定义行为类，该行为类可被继承更改。

- 继承主类时，可以实现继承的行为类

- `strategy_pattern.cpp`

### 观察者模式

- 观察者，定义对象之间的一对多依赖，这样当一个对象改变状态时，它的所有依赖者会被通知并自动更新

##### 示例 (一个数据中心，多个显示终端)

- 多个观察者从数据中心中提取数据

- 里面有循环引用，需要使用 weak_ptr

- `observer_pattern.cpp`

### 装饰器模式

- 装饰器，给对象动态附加额外的责任

- 一个抽象类，多个实现类，一个装饰器抽象类(继承抽象类，达到类型匹配)

- 多个装饰器实现类可以扩展实现类，用组合和委托的形式来扩展

- 优点：遵循开放闭合原则，扩展性更好

- 缺点：类的个数会很多

##### 示例 (咖啡店对不同咖啡添加不同配料，计算价格)

- 饮料是抽象类，浓缩、家常、烘焙、低咖啡因是实现类

- 配料是装饰器抽象类, 封装实现类

- `decorator_pattern.cpp`

### 工厂方法模式

- 在实践中发现，多对多的情况，组合的形式更具有弹性，两个基类，分别可以有派生类，通过组合可以实现弹性设计

- 简单工厂模式 和 工厂方法模式 有一些不同，简单工厂是生产物品的逻辑都在工厂类中，工厂类与使用类组合在一起;工厂方法模式是将一个方法模拟成工厂，子类在继承后可以有自己的工厂方法，进而由子类个性化创建产品

- “工厂方法模式定义了一个创建对象的接口，但让子类决定要实例化哪个类”

- 书上给的例子是多个披萨店有各自风格的披萨，如果都交给一个工厂，那这一个工厂依赖的具体类太多，进而需要每个披萨店有自己的工厂方法

##### 示例（不同披萨店制作自己风格的披萨）

- 披萨店类有一个抽象工厂方法，具体披萨店类继承后实现自己的工厂方法

- 这个示例用来说明 "依赖倒置" 原则 (依赖抽象，不依赖具体类)，工厂方法模式中的披萨是抽象类，工厂模式中依赖大量具体类导致设计弹性差

- 依赖倒置中的 "倒置" 是指依赖具体类时，是由高层依赖低层；依赖抽象时，部分具体实现类转为由低层依赖高层

- `factory_methoc_pattern.cpp`

### 抽象工厂模式

- 形式类似于策略模式，但主要作用是生产产品，所以叫工厂模式

- 不同于工厂方法主要使用类继承实现，抽象工厂主要使用组合实现，抽象产品中拥有抽象工厂

- 定义：抽象工厂模式提供一个接口来创建相关或依赖对象的家族，而不需要指定具体类

- 抽象工厂中的一个方法用于创建一组产品，是工厂方法模式

- 可以理解为抽象工厂由工厂方法组成，用于创建一个产品家族，需要一个大接口，如果有改变需求，可能改动会比较大；而工厂方法模式只有一个接口，创建单个产品，改动较小

- `abstract_factory_pattern.cpp`

### 单件模式

- 确保一个类只有一个实例，并提供全局访问点

- `singleton_pattern.cpp`

### 命令模式

- 客户创建调用者、命令、接收者对象；将接收者，即实际执行者的接口封装在命令的 execute() 接口中

- 调用者与命令组合，调用者调用命令的 execute() 接口；命令与接收者组合，调用 execute() 接口则调用接收者的接口

- 每条命令都有一个 undo() 接口，可以用来实现撤销功能

- 常用在线程池、任务队列、事务性日志场景中

- `command_pattern.cpp`

### 适配器模式

- 实现一个接口，封装多个类，使用封装的类的方法，实现接口中的类方法

- 类似装饰器模式，装饰器实现自身接口，适配器封装一个或多个类来实现一个接口

  - 装饰器用于在之前的类方法上添加一些新的责任
  - 适配器用于转换接口

- 定义：将一个类的接口转换成客户期望的另一个接口，让原本不兼容的类可以合作

- 对象适配器和类适配器

  - 对象适配器使用组合的形式，将目标类和被适配类解耦，保持弹性
  - 类适配器使用多重继承的形式，适配器类继承目标类和被适配类，能够快速覆盖被适配类的方法
  - 各有优势，但对象适配器更符合设计模式的原则，用的比较多

- 添加一个适配器，将火鸡封装成鸭子

  - `adapter_pattern.cpp`

### 外观模式

- 封装多个组件，提供外观接口简化场景，调用接口后执行多个组件的接口

- 外观模式和适配器模式都可以封装一个或多个组件，但它们的目的不同

  - 适配器模式的目的是转换接口
  - 外观模式的目的是提供子系统的一个简化的接口

- 定义：为子系统中的一组接口提供了一个统一的接口，定义一个更高级别的接口，使得子系统更容易使用

- 例：构建一个家庭影院，一键启动和停止

  - `facade_pattern.cpp`

### 模板方法模式

- 基类提供一个模板方法，模板方法中定义一个算法的步骤，其中这些步骤可以由基类实现一部分，也可以由派生类继承后改写

- 定义：在一个方法中定义一个算法的骨架，而把一些步骤延迟到子类

- 抽象方法与钩子

  - 抽象方法是基类中的接口，是子类必须实现的方法
  - 钩子用来控制模板中的流程，基类提供一个默认值，子类可以选择实现

- 此模式常用于创建框架，框架控制该做什么事，让使用框架的人指定框架算法中每个步骤实际发生的细节

- 常见于 C++ 的模板实现中，主模板提供算法流程，可以选择自定义比较函数（类似钩子）

- 模板方式采用继承的方式，策略模式采用组合的方式

- 工厂方法是模板方法的一个特例

- 例：使用相同流程制作咖啡和茶

  - `template_method_pattern.cpp`

### 迭代器模式

- 当多个集合合并后，需要遍历不同类型的集合，使用迭代器进行封装。调用者不需要知道每个集合具体是如何存储的。

- 定义：提供一种方式，可以访问一个聚合对象中的元素而又不暴露其潜在的表示

- 例：两个餐厅菜单合并，一个菜单采用链表，另一个菜单采用数组

  - `iterator_pattern.cpp`

  - 一次菜单遍历创建一个迭代器。采用的是外部迭代器的方式，能够直接调用 next() 控制遍历

### 组合模式

- 定义：允许将对象组合成树形结构来表现部分-整体层次结构。组合让客户可以统一处理个别对象和对象组合。

- 基类是组件，子类是组合或叶子，即一个组件可以是组合或叶子，组合中可以包含更多组件，最终形成树形结构

- 例：实现一个菜单树，节点可以是菜单或菜单项，菜单中包含菜单项

  - `composite_pattern.cpp`

### 状态模式

- 定义：允许对象在内部状态改变时改变其行为，对象看起来好像改变了它的类

- 状态模式类图和策略模式类图相似，但意图不同

  - 策略模式封装了算法，在运行时通常已经有合适的策略对象，且一般不会变动
  - 状态模式也封装了算法，在整个运行过程中，状态会不断进行转换

- 封装基于状态的行为并把行为委托给当前状态

- 和过程状态机不同，状态模式用真正的类代表每个状态

- 例：糖果机，最开始的实现是将所有状态转换逻辑放在糖果机中，但增减状态需要修改糖果机大量代码

  - 将状态封装成对象，糖果机中组合状态对象
  - 客户调用糖果机方法，糖果机调用当前状态对象进行状态转换行为
  - 状态对象拥有糖果机对象，状态发生改变时可以修改糖果机当前的状态，由状态决定下一个状态是什么
  - 这里的糖果机也被可以称作“上下文”

  - `state_pattern.cpp`

### 代理模式

- 定义：为另一个对象提供一个替身或占位符来控制对这个对象的访问

- 使用代理模式创建代表对象。代表对象控制对另一个对象的访问，被代表对象可以是远程的对象、创建开销大的对象或需要安全控制的对象。

- 代理控制访问的几种方式：

  - 远程代理控制对远程对象的访问

    - 通过网络访问远程对象的方法。

    - 网络代理包括两部分。一部分是接收客户请求，将请求序列化。另一部分在服务端，接受客户端的代理发出的序列化请求，处理后发送给实际处理的对象

  - 虚拟代理控制对创建开销大的资源的访问

    - 可以延迟对象的创建，直到真正需要。即代理对象也可以处理部分请求，处理不了再创建实际对象，或者在等待创建实际对象时做其他操作

    - 书上的例子是访问页面时由于网络问题，无法一次性显示，可以由代理对象显示“正在加载中”的提示，避免长时间挂起

  - 保护代理基于权限控制对资源的访问
    
    - 书上的例子是交友信息的访问代理，自己对自己可以配置个人信息，但是不能修改自己的评分；自己对他人不能配置个人信息，但能修改自己的评分

- 代理模式的类图类似装饰器模式，但代码模式强调间接性，且目的不一样。

  - 装饰者为对象添加行为，代理控制对象的访问

  - 装饰者在创建时需要被装饰者已经存在，而代理模式的间接性可以支持服务端和客户端分离（远程代理）和延迟对象创建（虚拟代理）
