# 设计模式概述

- 软件开发：招式+内功
  - 招式：开发语言+框架
  - 内功：数据结构、算法、设计模式、重构、软件工程

### 设计原则

- 抽取变化的部分

- 针对接口编程，而不是针对实现编程

- 优先使用组合而不是继承

- 尽量做到交互的对象之间松耦合设计

- 类应该对扩展开放，但对修改关闭

  - 新需求通过添加新代码(类的继承或添加新方法)，避免修改已经实现和测试好的代码

- 依赖抽象，不依赖具体类

### 策略模式

- 定义了一个算法族，分别封装起来，使得它们之间可以互相变换。策略让算法的变化独立于使用它的客户。

##### 示例 (不同鸭子的不同叫声)

- 主类中定义行为类，该行为类可被继承更改。

- 继承主类时，可以实现继承的行为类

- `strategy_pattern.cpp`

### 观察者模式

- 观察者，定义对象之间的一对多依赖，这样当一个对象改变状态时，它的所有依赖者会被通知并自动更新

##### 示例 (一个数据中心，多个显示终端)

- 多个观察者从数据中心中提取数据

- 里面有循环引用，需要使用 weak_ptr

- `observer_pattern.cpp`

### 装饰器模式

- 装饰器，给对象动态附加额外的责任

- 一个抽象类，多个实现类，一个装饰器抽象类(继承抽象类，达到类型匹配)

- 多个装饰器实现类可以扩展实现类，用组合和委托的形式来扩展

- 优点：遵循开放闭合原则，扩展性更好

- 缺点：类的个数会很多

##### 示例 (咖啡店对不同咖啡添加不同配料，计算价格)

- 饮料是抽象类，浓缩、家常、烘焙、低咖啡因是实现类

- 配料是装饰器抽象类, 封装实现类

- `decorator_pattern.cpp`

### 工厂方法模式

- 在实践中发现，多对多的情况，组合的形式更具有弹性，两个基类，分别可以有派生类，通过组合可以实现弹性设计

- 简单工厂模式 和 工厂方法模式 有一些不同，简单工厂是生产物品的逻辑都在工厂类中，工厂类与使用类组合在一起;工厂方法模式是将一个方法模拟成工厂，子类在继承后可以有自己的工厂方法，进而由子类个性化创建产品

- “工厂方法模式定义了一个创建对象的接口，但让子类决定要实例化哪个类”

- 书上给的例子是多个披萨店有各自风格的披萨，如果都交给一个工厂，那这一个工厂依赖的具体类太多，进而需要每个披萨店有自己的工厂方法

##### 示例（不同披萨店制作自己风格的披萨）

- 披萨店类有一个抽象工厂方法，具体披萨店类继承后实现自己的工厂方法

- 这个示例用来说明 "依赖倒置" 原则 (依赖抽象，不依赖具体类)，工厂方法模式中的披萨是抽象类，工厂模式中依赖大量具体类导致设计弹性差

- 依赖倒置中的 "倒置" 是指依赖具体类时，是由高层依赖低层；依赖抽象时，部分具体实现类转为由低层依赖高层

- `factory_methoc_pattern.cpp`
