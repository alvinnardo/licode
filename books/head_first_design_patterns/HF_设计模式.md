# 设计模式概述

- 软件开发：招式+内功
  - 招式：开发语言+框架
  - 内功：数据结构、算法、设计模式、重构、软件工程

### 设计原则

- 抽取变化的部分

- 针对接口编程，而不是针对实现编程

- 优先使用组合而不是继承

- 尽量做到交互的对象之间松耦合设计

- 类应该对扩展开放，但对修改关闭

  - 新需求通过添加新代码(类的继承或添加新方法)，避免修改已经实现和测试好的代码

- 依赖抽象，不依赖具体类

- 最少知识原则：只和你的密友谈话

  - 当在设计系统时，对于任何对象，要注意与它所交互的类的数量，以及它和这些类如何交互
  - 封装对象后，只调用封装对象的方法，而不调用封装对象内封装对象的方法
  - 如果想要调用封装对象内的封装对象的方法，就一个函数获取封装对象的封装对象，再一个函数调用其方法

    ```cpp
    struct A {
        void output();
    };
    struct B {
        A a;
    };
    struct C {
        B b; // 封装对象
        void test() { helper(b.a); } // 调用封装对象内的封装对象
        void helper(A &a) { a.output(); }
    };

    ```

### 策略模式

- 定义了一个算法族，分别封装起来，使得它们之间可以互相变换。策略让算法的变化独立于使用它的客户。

##### 示例 (不同鸭子的不同叫声)

- 主类中定义行为类，该行为类可被继承更改。

- 继承主类时，可以实现继承的行为类

- `strategy_pattern.cpp`

### 观察者模式

- 观察者，定义对象之间的一对多依赖，这样当一个对象改变状态时，它的所有依赖者会被通知并自动更新

##### 示例 (一个数据中心，多个显示终端)

- 多个观察者从数据中心中提取数据

- 里面有循环引用，需要使用 weak_ptr

- `observer_pattern.cpp`

### 装饰器模式

- 装饰器，给对象动态附加额外的责任

- 一个抽象类，多个实现类，一个装饰器抽象类(继承抽象类，达到类型匹配)

- 多个装饰器实现类可以扩展实现类，用组合和委托的形式来扩展

- 优点：遵循开放闭合原则，扩展性更好

- 缺点：类的个数会很多

##### 示例 (咖啡店对不同咖啡添加不同配料，计算价格)

- 饮料是抽象类，浓缩、家常、烘焙、低咖啡因是实现类

- 配料是装饰器抽象类, 封装实现类

- `decorator_pattern.cpp`

### 工厂方法模式

- 在实践中发现，多对多的情况，组合的形式更具有弹性，两个基类，分别可以有派生类，通过组合可以实现弹性设计

- 简单工厂模式 和 工厂方法模式 有一些不同，简单工厂是生产物品的逻辑都在工厂类中，工厂类与使用类组合在一起;工厂方法模式是将一个方法模拟成工厂，子类在继承后可以有自己的工厂方法，进而由子类个性化创建产品

- “工厂方法模式定义了一个创建对象的接口，但让子类决定要实例化哪个类”

- 书上给的例子是多个披萨店有各自风格的披萨，如果都交给一个工厂，那这一个工厂依赖的具体类太多，进而需要每个披萨店有自己的工厂方法

##### 示例（不同披萨店制作自己风格的披萨）

- 披萨店类有一个抽象工厂方法，具体披萨店类继承后实现自己的工厂方法

- 这个示例用来说明 "依赖倒置" 原则 (依赖抽象，不依赖具体类)，工厂方法模式中的披萨是抽象类，工厂模式中依赖大量具体类导致设计弹性差

- 依赖倒置中的 "倒置" 是指依赖具体类时，是由高层依赖低层；依赖抽象时，部分具体实现类转为由低层依赖高层

- `factory_methoc_pattern.cpp`

### 抽象工厂模式

- 形式类似于策略模式，但主要作用是生产产品，所以叫工厂模式

- 不同于工厂方法主要使用类继承实现，抽象工厂主要使用组合实现，抽象产品中拥有抽象工厂

- 定义：抽象工厂模式提供一个接口来创建相关或依赖对象的家族，而不需要指定具体类

- 抽象工厂中的一个方法用于创建一组产品，是工厂方法模式

- 可以理解为抽象工厂由工厂方法组成，用于创建一个产品家族，需要一个大接口，如果有改变需求，可能改动会比较大；而工厂方法模式只有一个接口，创建单个产品，改动较小

- `abstract_factory_pattern.cpp`

### 单件模式

- 确保一个类只有一个实例，并提供全局访问点

- `singleton_pattern.cpp`

### 命令模式

- 客户创建调用者、命令、接收者对象；将接收者，即实际执行者的接口封装在命令的 execute() 接口中

- 调用者与命令组合，调用者调用命令的 execute() 接口；命令与接收者组合，调用 execute() 接口则调用接收者的接口

- 每条命令都有一个 undo() 接口，可以用来实现撤销功能

- 常用在线程池、任务队列、事务性日志场景中

- `command_pattern.cpp`

### 适配器模式

- 实现一个接口，封装多个类，使用封装的类的方法，实现接口中的类方法

- 类似装饰器模式，装饰器实现自身接口，适配器封装一个或多个类来实现一个接口

  - 装饰器用于在之前的类方法上添加一些新的责任
  - 适配器用于转换接口

- 定义：将一个类的接口转换成客户期望的另一个接口，让原本不兼容的类可以合作

- 对象适配器和类适配器

  - 对象适配器使用组合的形式，将目标类和被适配类解耦，保持弹性
  - 类适配器使用多重继承的形式，适配器类继承目标类和被适配类，能够快速覆盖被适配类的方法
  - 各有优势，但对象适配器更符合设计模式的原则，用的比较多

- 添加一个适配器，将火鸡封装成鸭子

  - `adapter_pattern.cpp`

### 外观模式

- 封装多个组件，提供外观接口简化场景，调用接口后执行多个组件的接口

- 外观模式和适配器模式都可以封装一个或多个组件，但它们的目的不同

  - 适配器模式的目的是转换接口
  - 外观模式的目的是提供子系统的一个简化的接口

- 定义：为子系统中的一组接口提供了一个统一的接口，定义一个更高级别的接口，使得子系统更容易使用

- 例：构建一个家庭影院，一键启动和停止

  - `facade_pattern.cpp`
