#include "../template/head.h"
#include <bits/stdc++.h>

/**
  1. 0-1 背包
  a. 转移方程为 f[i][v] = max(f[i - 1][v], f[i - 1][v - c[i]] + w[i])
     就是对于第 i 个物品放与不放
     第一个下标是物品下标，第二个下标是背包容量
  b. 优化空间 f[v] = max(f[v], f[v - c[i]] + w[i])
     从后往前遍历，因为对于每一个容量，都需要之前的容量，
     如果从前往后遍历，之前的容量就被覆盖了
  c. 考虑初始化的问题
     - 如果题目没有要求恰好装满，则 f[0][0..n] 初始化为 0
     - 如果题目要求恰好装满，则 f[0][0] 初始化为 0，其余为负无穷
  b. 时间 O(NV)
 */

/**
  2. 完全背包
  a. 转化为 0-1 背包，每个物品的数量为 k = v/c[i]
     转移方程为 f[i][v] = max(f[i - 1][v], f[i - 1][v - k * c[i]] + k * w[i])
  b. 考虑重复的物品，后面的个数可以用前面的个数表示，
     比如先判断 1 个放几个，然后判断前 2 个放几个，再判断前 k 个放几个的最大值，
     所以转移方程为 f[i][v] = max(f[i - 1][v], f[i][v - c[i]] + w[i])，
     从同一行跳过来，表示再前面结果的基础上转移
  c. 考虑优化空间，以为不需要之前物品的值，需要当前物品的前序值，
     可以从前往后遍历，所以转移方程为 f[v] = max(f[v], f[v - c[i]] + w[i])
  d. 时间 O(NV)
 */

/**
  3. 多重背包
  a. 转换为 0-1 背包，ki 是每个元素的个数，时间 O(V * sum(ki))
     转移方程为 f[i][v] = max(f[i - 1][v], f[i - 1][v - ki * c[i]] + ki * w[i])
  b. 考虑将个数转为二进制表示，比如 13 表示为 1 + 2 + 4 + 6，
     前面都是 2 的 n 次方，时间能优化到 O(V * log(n[i]))
  c. 可以用单调队列的方法将时间复杂度减到 O(NV)
 */

/**
  4. 混合背包
  a. 是 0-1 背包、完全背包、多重背包的组合
  b. 可以对于每一个物品，调用对应的递推公式
 */

/**
  5. 多维背包
  a. 多加一维，转移方程为 f[v][u] = max(f[v][u], f[v-a[i]][u-b[i]] + w[i])
 */

/**
  6. 分组背包
  a. 每一组最多选一个，k 为物品的分组
     转移方程为 f[k][v] = max(f[k - 1][v], f[k - 1][v - c[i]] + w[i])
 */

/**
  7. 依赖背包
  a. 选 a 则必须选 b，这个可以转化为分组背包
 */

/**
  8. 泛化背包
 */

/**
  9. 变化背包
  */

int main(int argc, char *argv[]) { return 0; }
